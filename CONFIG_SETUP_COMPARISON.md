# Config Setup: Original vs Minimal Comparison

## Overview

Both configurations follow a similar pattern but differ significantly in complexity. Here's how each sets up the OpenClaw configuration.

## Configuration Flow

### Original (Essamamdani)
```
Docker Compose env vars → bootstrap.sh → openclaw.json → OpenClaw runtime
```

### Minimal (EasyClaw)
```
Backend PortAllocationService → Docker Compose env vars → bootstrap.sh → openclaw.json → OpenClaw runtime
     ↓
Backend generates token ───────────────────────────────────────────────┘
```

## Detailed Comparison

### 1. Environment Variable Strategy

#### Original: "Kitchen Sink" Approach
The original includes **40+ environment variables** in docker-compose.yaml:
- All API keys for all AI providers (OpenAI, MiniMax, Anthropic, Gemini, Kimi, Opencode)
- Optional integrations (Google Maps, ElevenLabs, NanoBanana)
- Deployment tools (Vercel tokens, GitHub credentials)
- Public access (Cloudflare tunnel)
- System settings (Bun, NPM cache, XDG paths)

**Key Pattern**: Everything is explicitly defined with defaults
```yaml
OPENAI_API_KEY: ${OPENAI_API_KEY}
MINIMAX_API_KEY: ${MINIMAX_API_KEY}
ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY}
# ... 40+ more
```

#### Minimal: "Bring What You Have" Approach
The minimal version includes **~15 environment variables**:
- Required core config (PORT, STATE_DIR, WORKSPACE)
- Token (generated by backend or provided)
- AI providers (with empty defaults)
- Optional Telegram
- Container identification (for backend tracking)

**Key Pattern**: Only essentials + flexible AI providers
```yaml
# Required - set by backend
OPENCLAW_GATEWAY_PORT: ${OPENCLAW_GATEWAY_PORT}
OPENCLAW_GATEWAY_TOKEN: ${OPENCLAW_GATEWAY_TOKEN}

# AI providers - user provides what they have
OPENAI_API_KEY: ${OPENAI_API_KEY}
ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY:-}
GEMINI_API_KEY: ${GEMINI_API_KEY:-}
```

**Both Work the Same**: If user only provides `OPENAI_API_KEY`, both configs work fine. The difference is just how many placeholders exist.

### 2. Bootstrap Script Logic

#### Original: Complex Multi-Stage Setup (214 lines)

**Step 1: Migration**
```bash
if [ -f "/app/scripts/migrate-to-data.sh" ]; then
    bash "/app/scripts/migrate-to-data.sh"
fi
```
- Handles data migration from old paths

**Step 2: Directory Structure**
```bash
mkdir -p "$OPENCLAW_STATE" "$WORKSPACE_DIR"
mkdir -p "$OPENCLAW_STATE/credentials"
mkdir -p "$OPENCLAW_STATE/agents/main/sessions"
```
- Complex nested structure for agents

**Step 3: Symlink Setup**
```bash
for dir in .agents .ssh .config .local .cache .npm .bun .claude .kimi; do
    ln -sf "/data/$dir" "/root/$dir"
done
```
- Many symlinks for various CLI tools

**Step 4: Agent Workspace Seeding**
```bash
seed_agent() {
  # Copies SOUL.md and BOOTSTRAP.md
  # Handles "main" agent specially
  # Creates default SOUL.md for others
}
seed_agent "main" "OpenClaw"
```
- Copies personality files (SOUL.md)
- Seeding logic for multiple agents

**Step 5: Config Generation**
Generates a complex `openclaw.json` with:
- 7 command types enabled
- 3 plugins (whatsapp, telegram, google-auth)
- Skills configuration
- Gateway with control UI, tailscale, trusted proxies
- Agents with sandbox browser, heartbeat, maxConcurrent: 4

**Step 6: Sandbox Setup**
```bash
[ -f scripts/sandbox-setup.sh ] && bash scripts/sandbox-setup.sh
[ -f scripts/sandbox-browser-setup.sh ] && bash scripts/sandbox-browser-setup.sh
```
- Sets up sandbox base image
- Configures browser automation

**Step 7: Recovery & Monitoring**
```bash
cp scripts/recover_sandbox.sh "$WORKSPACE_DIR/"
cp scripts/monitor_sandbox.sh "$WORKSPACE_DIR/"
bash "$WORKSPACE_DIR/recover_sandbox.sh"
nohup bash "$WORKSPACE_DIR/monitor_sandbox.sh" &
```
- Copies recovery scripts
- Runs initial recovery
- Starts background monitor

**Step 8: Token Extraction**
```bash
SAVED_TOKEN=$(jq -r '.gateway.auth.token // empty' "$CONFIG_FILE")
```
- Reads token from previously generated config

**Step 9: Banner Display**
Shows detailed access info with:
- Local URL
- Public URL (if SERVICE_FQDN_OPENCLAW set)
- Onboarding instructions
- ULIMIT info

#### Minimal: Streamlined Setup (91 lines)

**Step 1: Environment Variables**
```bash
GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-18789}"
GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN:-}"
```
- Reads from environment or uses defaults

**Step 2: Simple Directory Structure**
```bash
mkdir -p "$OPENCLAW_STATE" "$WORKSPACE_DIR"
mkdir -p "$OPENCLAW_STATE/credentials"
```
- Flat structure, no agent subdirectories

**Step 3: Essential Symlinks Only**
```bash
for dir in .ssh .config .local .cache .npm; do
    ln -sf "/data/$dir" "/root/$dir"
done
```
- Only core symlinks (removed .bun, .claude, .kimi, .agents)

**Step 4: Token Handling**
```bash
if [ -z "$GATEWAY_TOKEN" ]; then
    echo "⚠️  No OPENCLAW_GATEWAY_TOKEN provided, generating new token..."
    GATEWAY_TOKEN=$(openssl rand -hex 24)
fi
```
- Accepts token from environment OR generates one
- Works with backend-generated tokens

**Step 5: Simple Config Generation**
Generates minimal `openclaw.json` with:
- 4 command types (core only)
- 1 plugin (telegram, conditional)
- Gateway with port, bind, auth token
- Agents with workspace, maxConcurrent: 2

**Step 6: Run**
- No recovery scripts
- No monitoring
- No sandbox setup (handled at runtime)
- Simple banner with container info

### 3. Generated openclaw.json Comparison

#### Original Config Structure
```json
{
  "commands": {
    "native": true,
    "nativeSkills": true,
    "text": true,
    "bash": true,
    "config": true,
    "debug": true,
    "restart": true,
    "useAccessGroups": true
  },
  "plugins": {
    "enabled": true,
    "entries": {
      "whatsapp": { "enabled": true },
      "telegram": { "enabled": true },
      "google-antigravity-auth": { "enabled": true }
    }
  },
  "skills": {
    "allowBundled": ["*"],
    "install": { "nodeManager": "npm" }
  },
  "gateway": {
    "port": 18789,
    "mode": "local",
    "bind": "lan",
    "controlUi": { "enabled": true, "allowInsecureAuth": false },
    "trustedProxies": ["*"],
    "tailscale": { "mode": "off", "resetOnExit": false },
    "auth": { "mode": "token", "token": "xxx" }
  },
  "agents": {
    "defaults": {
      "workspace": "/data/openclaw-workspace",
      "envelopeTimestamp": "on",
      "envelopeElapsed": "on",
      "cliBackends": {},
      "heartbeat": { "every": "1h" },
      "maxConcurrent": 4,
      "sandbox": {
        "mode": "non-main",
        "scope": "session",
        "browser": { "enabled": true }
      }
    },
    "list": [{ "id": "main", "default": true, "name": "default", "workspace": "..." }]
  }
}
```

#### Minimal Config Structure
```json
{
  "commands": {
    "native": true,
    "text": true,
    "bash": true,
    "config": true
  },
  "plugins": {
    "enabled": true,
    "entries": {
      "telegram": {
        "enabled": false  // Set based on TELEGRAM_BOT_TOKEN presence
      }
    }
  },
  "gateway": {
    "port": 18789,
    "bind": "lan",
    "auth": { "mode": "token", "token": "xxx" }
  },
  "agents": {
    "defaults": {
      "workspace": "/data/openclaw-workspace",
      "maxConcurrent": 2
    },
    "list": [{ "id": "main", "default": true, "workspace": "..." }]
  }
}
```

### 4. Key Differences Summary

| Aspect | Original | Minimal |
|--------|----------|---------|
| **Lines of Code** | 214 | 91 |
| **Config Size** | 23 fields | 12 fields |
| **Token Source** | Generated in bootstrap | Backend-provided OR generated |
| **Port** | Hardcoded 18789 | Dynamic from env |
| **Agent Seeding** | Complex with SOUL.md | None |
| **Recovery** | Full recovery + monitoring | None (simpler) |
| **Symlinks** | 8 directories | 5 directories |
| **Sandbox Setup** | Pre-configured | Runtime install |
| **Plugins** | 3 (whatsapp, telegram, google) | 1 (telegram, conditional) |
| **Commands** | 7 types | 4 types |
| **Heartbeat** | Every 1h | None |
| **Browser** | Enabled in config | Not mentioned |

### 5. What We Lose vs Gain

#### Losses (Minimal vs Original)
- ❌ Automatic recovery on restart
- ❌ Background health monitoring
- ❌ Browser automation pre-configured
- ❌ WhatsApp plugin enabled by default
- ❌ Heartbeat monitoring
- ❌ Multi-agent seeding
- ❌ Tailscale configuration
- ❌ Control UI settings

#### Gains (Minimal vs Original)
- ✅ Dynamic port allocation from backend
- ✅ Backend-generated tokens
- ✅ Simpler config = less to debug
- ✅ Faster startup (no recovery scripts)
- ✅ Lower resource usage
- ✅ Container identification for backend tracking

### 6. How EasyClaw Backend Uses This

#### Deployment Flow
```javascript
// container-deployment.ts

// 1. Allocate port
const gatewayPort = await portAllocationService.allocatePort(serverId);

// 2. Generate token
const gatewayToken = generateGatewayToken();

// 3. Create Coolify app with environment variables
const envVars = {
  CONTAINER_ID: applicationId,
  CONTAINER_NAME: containerName,
  OPENCLAW_GATEWAY_PORT: gatewayPort.toString(),
  OPENCLAW_GATEWAY_TOKEN: gatewayToken,
  OPENAI_API_KEY: request.envVars.OPENAI_API_KEY,
  TELEGRAM_BOT_TOKEN: request.envVars.TELEGRAM_BOT_TOKEN,
  // ... other user-provided vars
};

// 4. Bootstrap script uses these to generate openclaw.json
```

#### Why This Works
1. **Port**: Backend allocates free port, injects into container
2. **Token**: Backend generates secure token, container uses it
3. **Config**: Bootstrap reads env vars, generates valid openclaw.json
4. **AI Providers**: User provides API keys in deployment request
5. **Identification**: Backend tracks container via CONTAINER_ID/NAME

### 7. Adding Back Features

If you want the "kitchen sink" env vars back, just add them to docker-compose.yaml:

```yaml
environment:
  # Existing minimal vars...
  
  # Add back optional AI providers
  MINIMAX_API_KEY: ${MINIMAX_API_KEY:-}
  KIMI_API_KEY: ${KIMI_API_KEY:-}
  OPENCODE_API_KEY: ${OPENCODE_API_KEY:-}
  
  # Add back integrations
  ELEVENLABS_API_KEY: ${ELEVENLABS_API_KEY:-}
  GOOGLE_MAPS_API_KEY: ${GOOGLE_MAPS_API_KEY:-}
  
  # Add back deployment tools
  VERCEL_TOKEN: ${VERCEL_TOKEN:-}
  GITHUB_TOKEN: ${GITHUB_TOKEN:-}
```

The bootstrap script doesn't need to change - OpenClaw reads these from environment at runtime.

## Conclusion

**Original**: Maximum features, maximum complexity, assumes self-hosted with manual setup

**Minimal**: Core features only, streamlined for EasyClaw backend deployment, dynamic configuration

**Both**: Support "bring what you have" - if you only provide OPENAI_API_KEY, both work fine. The difference is the bootstrap complexity and what's pre-configured in openclaw.json.
